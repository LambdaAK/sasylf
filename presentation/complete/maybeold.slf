package presentation

module maybe

requires

abstract syntax e

abstract judgment combine: e + e = e

abstract theorem combine-comm:
  forall d: e1 + e2 = e3
  exists e2 + e1 = e3
end theorem

provides

terminals None Some

syntax m ::= None | Some e

judgment lifted-combine: m + m = m

  ----------------- lifted-combine-none-1
  None + m = None

  ----------------- lifted-combine-none-2
  m + None = None

  e1 + e2 = e3
  ----------------- lifted-combine-some
  Some e1 + Some e2 = Some e3

theorem lifted-combine-comm:
  forall d: m1 + m2 = m3
  exists m2 + m1 = m3
  proof by case analysis on d:
    case rule
      --------------- lifted-combine-none-1
      _: None + m2 = None
    is
      proof by rule lifted-combine-none-2
    end case

    case rule
      --------------- lifted-combine-none-2
      _: m1 + None = None
    is
      proof by rule lifted-combine-none-1
    end case

    case rule
      d1: e0 + e1 = e2
      --------------- lifted-combine-some
      _: (Some e0) + (Some e1) = (Some e2)
    is
      d2: e1 + e0 = e2 by theorem combine-comm on d1
      d3: Some e1 + Some e0 = Some e2 by rule lifted-combine-some on d2
      proof by d3
    end case

  end case analysis
end theorem