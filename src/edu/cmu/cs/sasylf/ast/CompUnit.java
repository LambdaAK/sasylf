package edu.cmu.cs.sasylf.ast;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

import edu.cmu.cs.sasylf.CloneData;
import edu.cmu.cs.sasylf.SubstitutionData;
import edu.cmu.cs.sasylf.module.Module;
import edu.cmu.cs.sasylf.module.ModuleFinder;
import edu.cmu.cs.sasylf.module.ModuleId;
import edu.cmu.cs.sasylf.module.NullModuleFinder;
import edu.cmu.cs.sasylf.util.ErrorHandler;
import edu.cmu.cs.sasylf.util.Errors;
import edu.cmu.cs.sasylf.util.Location;
import edu.cmu.cs.sasylf.util.ParseUtil;
import edu.cmu.cs.sasylf.util.SASyLFError;
import edu.cmu.cs.sasylf.util.Span;


public class CompUnit extends Node implements Module {
	public CompUnit(PackageDeclaration pack, Location loc, String n) {
		super(loc);
		packageDecl=pack; 
		moduleName = n; 
		updateReportCount();
	}

	/**
	 * Update the number of reports generated during parsing.
	 */
	protected void updateReportCount() {
		parseReports = ErrorHandler.getReports().size();
	}

	/**
	 * Add a chunk that is required by this module.
	 * @param c part to add, must not be null
	 */
	public void addParameterChunk(Part c) {
		params.add(c); 
		updateReportCount();
	}

	/**
	 * Add a part to this compilation unit.
	 * @param c
	 */
	public void addChunk(Part c) {
		parts.add(c);
		updateReportCount();
	}

	public PackageDeclaration getPackage() { return packageDecl; }

	/* (non-Javadoc)
	 * @see edu.cmu.cs.sasylf.ast.Module#getName()
	 */
	@Override
	public String getName() { return moduleName; }

	@Override
	public boolean isAbstract() {
		return !params.isEmpty();
	}

	private PackageDeclaration packageDecl;
	public String moduleName;
	private List<Part> params = new ArrayList<Part>();
	private List<Part> parts = new ArrayList<Part>();
	private int parseReports;

	public List<Part> getParams() {
		return params;
	}

	public List<Part> getParts() {
		return parts;
	}

	/* (non-Javadoc)
	 * @see edu.cmu.cs.sasylf.ast.Module#prettyPrint(java.io.PrintWriter)
	 */
	@Override
	public void prettyPrint(PrintWriter out) {
		packageDecl.prettyPrint(out);

		if (moduleName != null) {
			out.println("module " + moduleName);
		}

		if (!params.isEmpty()) {
			out.println("requires");
			for (Part part : params) {
				part.prettyPrint(out);
			}
			out.println("provides");
		}

		for (Part part : parts) {
			part.prettyPrint(out);
		}

		out.flush();
	}

	/**
	 * Return the number of reports generated by the parser before this
	 * compilation unit was generated.
	 * @return number of errors
	 */
	public int getParseReports() {
		return parseReports;
	}
	
	/* (non-Javadoc)
	 * @see edu.cmu.cs.sasylf.ast.Module#typecheck()
	 */
	@Override
	public boolean typecheck() {
		return typecheck(NullModuleFinder.get(),(ModuleId)null);  
	}

	/** Typechecks this compilation unit, returning true if the check was successful,
	 * false if there were one or more errors.
	 */
	public boolean typecheck(ModuleFinder mf, ModuleId id) {
		ErrorHandler.recordLastSpan(this);
		int oldCount = ErrorHandler.getErrorCount();
		Context ctx = new Context(mf,this);
		try {
			typecheck(ctx,id);
		} catch (SASyLFError e) {
			// ignore the error; it has already been reported
			//e.printStackTrace();
		}
		return ErrorHandler.getErrorCount() == oldCount;
	}

	/**
	 * Check this compilation unit in the given context.
	 * @param ctx context, must not be null
	 * @param id identifier declared for this compilation unit, or null if no declared module name
	 */
	public void typecheck(Context ctx, ModuleId id) {

		if (id != null) checkFilename(id);
		for (Part part : params) {
			try {
				part.typecheck(ctx);
				if (part instanceof JudgmentPart) {
					List<Node> pieces = new ArrayList<>();
					part.collectTopLevel(pieces);
					for (Node n : pieces) {
						if (n instanceof Judgment) {
							Judgment j = (Judgment)n;
							if (!j.isAbstract() && j.getRules().isEmpty()) {
								ErrorHandler.recoverableError(Errors.ABSTRACT_REQUIRED, j);
							}
						}
					}
				}
			} catch (SASyLFError ex) {
				// already reported
			}
		}
		for (Part part : parts) {
			try {
				part.typecheck(ctx);
			} catch (SASyLFError ex) {
				// already reported
			}
		}

		/*
		System.out.println("-------Finished typechecking CompUnit-------");

		// get the two modules

		CompUnit test2mod = (CompUnit) ctx.modMap.get("test2mod");
		CompUnit test3mod = (CompUnit) ctx.modMap.get("test3mod");

		if (test2mod == null || test3mod == null) return;

		SyntaxPart sp1 = (SyntaxPart) test2mod.getParts().get(1);
		SyntaxPart sp2 = (SyntaxPart) test3mod.getParts().get(1);

		// get the first syntax part from each one

		SyntaxDeclaration sd1 = (SyntaxDeclaration) sp1.getSyntax().get(0);
		SyntaxDeclaration sd2 = (SyntaxDeclaration) sp2.getSyntax().get(0);

		System.out.println("sd1: " + sd1);
		System.out.println("sd2: " + sd2);
		
		Clause c1 = sd1.getClauses().get(1);
		Clause c2 = sd2.getClauses().get(1);

		// get the s in each of the clauses - that's the index 2 element

		NonTerminal nt1 = (NonTerminal) c1.getElements().get(3);
		NonTerminal nt2 = (NonTerminal) c2.getElements().get(3);

		System.out.println("nt1: " + nt1);
		System.out.println("nt2: " + nt2);

		// check the types

		SyntaxDeclaration type1 = nt1.getType();
		SyntaxDeclaration type2 = nt2.getType();

		System.out.println("type1: " + type1);
		System.out.println("type2: " + type2);

		System.out.println("sd1 == type1 : " + (sd1 == type1));
		System.out.println("sd2 == type2 : " + (sd2 == type2));

		System.out.println("------- All Good -------");

		// get the ss and sss syntax declarations

		RenameSyntaxDeclaration ss = (RenameSyntaxDeclaration) ctx.getSyntax("ss");
		RenameSyntaxDeclaration sss = (RenameSyntaxDeclaration) ctx.getSyntax("sss");

		System.out.println(ss);
		System.out.println(sss);

		SyntaxDeclaration ssOriginal = ss.original;
		SyntaxDeclaration sssOriginal = sss.original;

		System.out.println("ssOriginal: " + ssOriginal);
		System.out.println("sssOriginal: " + sssOriginal);

		// check if they're equal to the original syntax declarations

		System.out.println("type1 == ssOriginal : " + (type1 == ssOriginal));
		System.out.println("type2 == sssOriginal : " + (type2 == sssOriginal));

		// check ss in the first judgment declared in the main module

		JudgmentPart jp = (JudgmentPart) getParts().get(7);

		RenameJudgment j1 = (RenameJudgment) jp.getJudgments().get(0);

		Clause j1Form = j1.getForm();

		// get the first nonterminal in the clause

		NonTerminal j1NT = (NonTerminal) j1Form.getElements().get(0);

		// get the type of the nonterminal

		RenameSyntaxDeclaration j1NTType = (RenameSyntaxDeclaration) j1NT.getType();

		SyntaxDeclaration j1NTOriginal = j1NTType.original;
		
		System.out.println("j1NTOriginal: " + j1NTOriginal);

		// check if it's equal to the original syntax declaration

		System.out.println("type1 == j1NTOriginal : " + (type1 == j1NTOriginal));
		
		// check s in the functor

		CompUnit test1mod = (CompUnit) ctx.modMap.get("test1mod");

		// get the first syntax part

		SyntaxPart sp = (SyntaxPart) test1mod.getParts().get(1);
		
		SyntaxDeclaration s1 = (SyntaxDeclaration) sp.getSyntax().get(0);
		
		NonTerminal s1NT = s1.getNonTerminal();

		SyntaxDeclaration s1NTType = s1NT.getType();

		System.out.println(s1NTType);

		System.out.println("-------------------");
		*/


		// get the theorem

	}

	private void checkFilename(ModuleId id) {
		packageDecl.typecheck(id.packageName);

		if (moduleName != null) {
			if (!ParseUtil.isLegalIdentifier(id.moduleName)) {
				ErrorHandler.error(Errors.BAD_FILE_NAME,this);
			}
			if (!moduleName.equals(id.moduleName)) {
				ErrorHandler.warning(Errors.WRONG_MODULE_NAME, this, moduleName+"\n"+id.moduleName);
			}
		}
		
	}

	/* (non-Javadoc)
	 * @see edu.cmu.cs.sasylf.ast.Module#collectTopLevel(java.util.Collection)
	 */
	@Override
	public void collectTopLevel(Collection<? super Node> things) {
		for (Part part : params) {
			part.collectTopLevel(things);
		}
		for (Part part : parts) {
			part.collectTopLevel(things);
		}
	}

	/* (non-Javadoc)
	 * @see edu.cmu.cs.sasylf.ast.Module#collectRuleLike(java.util.Map)
	 */
	@Override
	public void collectRuleLike(Map<String,? super RuleLike> map) {
		for (Part part : params) {
			part.collectRuleLike(map);
		}
		for (Part part : parts) {
			part.collectRuleLike(map);
		}
	}
	
	/**
	 * Collect all {@link QualName}s using the given consumer.
	 * @param consumer The consumer that accepts conditions based on the given {@link QualName}.
	 */
	@Override
	public void collectQualNames(Consumer<QualName> consumer) {
		for (Part part : params) {
			part.collectQualNames(consumer);
		}
		
		for (Part part : parts) {
			part.collectQualNames(consumer);
		}
	}

	private Map<String,Object> declCache = new HashMap<String,Object>();
	private int cacheVersion = -1;

	@Override
	public Object getDeclaration(Context ctx, String name) {

		// the bug fix is making this code always run
		// TODO: remove the true || part
		if (true || cacheVersion != ctx.version()) {
			declCache.clear();
			Collection<Node> things = new ArrayList<Node>();

			this.collectTopLevel(things);

			this.collectRuleLike(declCache); // doesn't get syntax declarations or judgments

			for (Node n : things) {
				if (n instanceof SyntaxDeclaration) {
					SyntaxDeclaration sd = (SyntaxDeclaration)n; // TODO: check here
					for (String s : sd.getAlternates()) {
						declCache.put(s, sd);
					}
				} else if (n instanceof Judgment) {
					Judgment jd = (Judgment)n; // TODO: check here
					declCache.put(jd.getName(),jd);
				}
			}
			cacheVersion = ctx.version();
		}
		Object result = declCache.get(name);

		return result;
	}

	public void substitute(SubstitutionData sd) {
		if (sd.didSubstituteFor(this)) return;
		sd.setSubstitutedFor(this);
		for (Part part : parts) {
			part.substitute(sd);
		}
	}

	public CompUnit copy(CloneData cd) {
		// unimplemented
		System.out.println("CompUnit.copy unimplemented");
		System.exit(0);
		return null;
	}

	@Override
	public CompUnit clone() {

		CloneData cd = new CloneData();

		CompUnit clone;

		try {
			clone = (CompUnit) super.clone();
		} catch (CloneNotSupportedException e) {
			System.out.println("Clone not supported in CompUnit");
			System.exit(1);
			return null;
		}
	
		clone.packageDecl = packageDecl.copy(cd);

		List<Part> newParams = new ArrayList<>();
		for (Part p: params) {
			newParams.add(p.copy(cd));
		}
		clone.params = newParams;

		List<Part> newParts = new ArrayList<>();
		for (Part p : parts) {
			newParts.add(p.copy(cd));
		}
		clone.parts = newParts;

		return clone;
	}
}
